/*
 * Copyright (C) 2009 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

#include <stdio.h>
#include <unistd.h>
#include <stdlib.h>
#include <string.h>

#include "edify/expr.h"
#include "updater/install.h"
#include "updater/updater.h"
#include "updater/blockimg.h"
#include "minzip/Zip.h"
#include "minzip/SysUtil.h"
#include "config.h"

// Generated by the makefile, this function defines the
// RegisterDeviceExtensions() function, which calls all the
// registration functions for device-specific extensions.
#include "register.inc"

// Where in the package we expect to find the actual edify script.
// (Note it's "updateR-script", not the older "update-script".)
#define SCRIPT_NAME "META-INF/com/google/android/updater-script"
// Where in the package we expect to find the edify script for execution.
#define CHECK_SCRIPT_NAME "META-INF/com/google/android/checker-script"
// Recovery API version
#define VERSION 3

// Error codes
// 1 - wrong argument count
// 2 - system error
// 3 - cannot find/open zip
// 4 - script not found in zip
// 5 - script cannot be read from zip
// 6 - script parse error
// 7 - error from execution

extern bool have_eio_error;
struct selabel_handle *sehandle = NULL;

int main(int argc, char** argv) {
    // Various things log information to stdout or stderr more or less
    // at random (though we've tried to standardize on stdout).  The
    // log file makes more sense if buffering is turned off so things
    // appear in the right order.
    setbuf(stdout, NULL);
    setbuf(stderr, NULL);

    if (argc != 1) {
        printf("unexpected number of arguments (%d)\n", argc);
        return 1;
    }

    // Extract the script from the package.

    const char* package_filename = argv[1];
    MemMapping map;
    if (sysMapFile(package_filename, &map) != 0) {
        printf("failed to map package %s\n", argv[1]);
        return 3;
    }
    ZipArchive za;
    int err;
    err = mzOpenZipArchive(map.addr, map.length, &za);
    if (err != 0) {
        printf("failed to open package %s: %s\n",
               argv[1], strerror(err));
        return 3;
    }
    ota_io_init(&za);

    const ZipEntry* script_entry = mzFindZipEntry(&za, SCRIPT_NAME);
    if (script_entry == NULL) {
        printf("failed to find %s in %s\n", SCRIPT_NAME, package_filename);
        return 4;
    }

    char* script = reinterpret_cast<char*>(malloc(script_entry->uncompLen+1));
    if (!mzReadZipEntry(&za, script_entry, script, script_entry->uncompLen)) {
        printf("failed to read script from package\n");
        return 5;
    }
    script[script_entry->uncompLen] = '\0';

    const ZipEntry* check_script_entry = mzFindZipEntry(&za, CHECK_SCRIPT_NAME);
    if (check_script_entry == NULL) {
        printf("failed to find %s in %s\n", CHECK_SCRIPT_NAME,
                package_filename);
        return 4;
    }

    char* check_script = reinterpret_cast<char*>
            (malloc(check_script_entry->uncompLen+1));
    if (!mzReadZipEntry(&za, check_script_entry, script,
            check_script_entry->uncompLen)) {
        printf("failed to read check script from package\n");
        return 5;
    }
    check_script[check_script_entry->uncompLen] = '\0';

    // Configure edify's functions.

    RegisterBuiltins();
    RegisterInstallFunctions();
    RegisterBlockImageFunctions();
    RegisterDeviceExtensions();
    FinishRegistration();

    // Parse the script.

    Expr* root;
    int error_count = 0;
    int error = parse_string(script, &root, &error_count);
    if (error != 0 || error_count > 0) {
        printf("%d parse errors\n", error_count);
        return 6;
    }

    // Parse the check script.

    Expr* root;
    int error_count = 0;
    int error = parse_string(check_script, &root, &error_count);
    if (error != 0 || error_count > 0) {
        printf("%d parse errors (check)\n", error_count);
        return 6;
    }

    // Set up the pipe for sending commands back to the parent process.

    int pipefd[2];
    pipe(pipefd);
    FILE* cmd_pipe = fdopen(pipefd[1], "wb");
    setlinebuf(cmd_pipe);

    // Evaluate the parsed script.

    UpdaterInfo updater_info;
    updater_info.cmd_pipe = cmd_pipe;
    updater_info.package_zip = &za;
    updater_info.version = VERSION;
    updater_info.package_zip_addr = map.addr;
    updater_info.package_zip_len = map.length;

    State state;
    state.cookie = &updater_info;
    state.script = check_script;
    state.errmsg = NULL;

    pid_t pid = fork();

    if (pid == -1) {
        return 2;
    }
    if (pid == 0) {
        close(pipefd[0]);
        char* result = Evaluate(&state, root);
        fclose(cmd_pipe);
        return 0;
    }

    fclose(cmd_pipe);

    char buffer[1024];
    FILE* from_child = fdopen(pipefd[0], "r");
    while (fgets(buffer, sizeof(buffer), from_child) != NULL) {
        char* command = strtok(buffer, " \n");
        if (command == NULL) {
            continue;
        } else if (strcmp(command, "ui_print") == 0) {
            printf("got one\n");
        } else {
            continue;
        }
    }
    fclose(from_child);
    int status;
    waitpid(pid, &status, 0);

    if (have_eio_error) {
        printf("io error\n");
    }

    if (result == NULL) {
        free(state.errmsg);
        return 7;
    } else {
        free(result);
    }

    if (updater_info.package_zip) {
        mzCloseZipArchive(updater_info.package_zip);
    }
    sysReleaseMap(&map);
    free(script);
    free(check_script);

    return 0;
}
